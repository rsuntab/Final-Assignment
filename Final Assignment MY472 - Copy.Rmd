---
Title: "Final Assignment MY472"
Author: "202326921"
Date: "10 January 2024"
output: 
  html_document:
    toc: true
    toc_float: true
---

# 1. Introduction {#exercise-1}

**“Rolling Stone Magazine ranked their 100 greatest musical artists of all time. At the end of 2023, how has their music endured? Are there any features or characteristics that seem to explain enduring engagement?”**

Music is something that is present in everyone's life. That's why it's interesting to investigate how music evolves over time and what factors make certain music endure, influence, and impact more than others. This work will attempt to analyze these elements.

For more information, you can find here the [Final Assignment MY472 GitHub Repository](https://github.com/rsuntab/Final-Assignment-MY472) for this project.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# We will first load all the packages that we need for this assignment 
# We call 'suppresWarnings()' to omit the warnings in the knitted document - in case we get some
suppressWarnings(library('DBI'))
suppressWarnings(library('RSQLite'))
library('rvest')
library('RSelenium')
library('httr') 
library('dplyr')
library('ggplot2')
library('leaflet')
library('rnaturalearth')
library('stringr')
library('plotly')
library('shiny')
```

Before starting the work, we create a relational database that we call **'finalassignment'**, where we will store all the information that we need for the analysis. This is efficient because once we run the code, we don't need to scrape the data more times.

```{r}

# STEP 1. CREATING THE RELATIONAL DATABASE -----------------------------------

# We create the path to a SQLite database file 
mydatabase <- "./database/finalassignment.sqlite"

#We create the connection to this database
connection <- dbConnect(RSQLite::SQLite(), mydatabase)

#We check for the existence of the relational database
if (file.exists(mydatabase)) {
  print("Database file exists.")
} else {
  print("Error: Database file not found.")
}
```

# 2. Data {#exercise-2}

The data to be analyzed comes from four different sources of information, obtained through web scraping techniques for both structured and unstructured data. Packages such as 'rvest,' 'RSelenium,' or 'httr' are essential in this regard. Two of the sources used are mandatory:

1) **Rolling Stone Magazine**: Provides information about the 100 greatest artists in history. Through it, we obtain their names and the ranking attributed to them.
2) **Spotify API**: Provides information about the artists themselves. In this case, only some information about the artists, their albums, and their top tracks has been included, as it is the most relevant. It is worth noting:

    * Music genres have been grouped in: Rock, Soul/R&B, Metal, Blues, Hip Hop/Rap, Country/Folk, Pop, Punk, Reggae. A condition has been established to link each artist to the musical genre most closely associated with their style. This classification will serve for a clearer analysis of how musical genres have evolved.
    
    
This information has been structured into three different tables saved in a relational database called 'finalassignment.' We can check its structure below:

```{r, eval = FALSE}
# STEP 2. WE GET THE 100 ARTISTS' NAMES -------------------------------

# We gather the artists data from the Rolling Stone article - Names and ranks of the 100 best artists of history

# First, we construct a table where we are going to store the information
# Initialize an empty data frame
artists_data <- data.frame(rank = character(), artist = character(), stringsAsFactors = FALSE)

# Define the function to get artists
get_artists <- function(const_name, sec = 4){
  
  # 1. Setup -----------------------------
  # We establish the website  
  url <- 'https://www.rollingstone.com/music/music-lists/100-greatest-artists-147446/'
  
  # We start the Selenium server:
  rD <- rsDriver(browser=c("firefox"), verbose = F, port = netstat::free_port(random = TRUE), chromever = NULL) 
  driver <- rD[["client"]] 
  
  # We navigate to the selected URL address
  driver$navigate(url)
  
  # We wait for the page to load
  Sys.sleep(3)
  
  # We accept the privacy terms
  accept_button <- driver$findElement(using = "xpath", value = "//button[contains(text(), 'I Accept')]")
  if (!is.null(accept_button)) {
    accept_button$clickElement()
  }  
  
  # We wait for the page to load
  Sys.sleep(3)
  
  # Initialize the data frame
  artists_data <- data.frame(rank = character(), artist = character(), stringsAsFactors = FALSE)
  
  # 2. Search and extract results ----------------------------------------
  # Extract information for the first 50 artists
  artists_1_50 <- driver$findElements("css selector", ".c-gallery-vertical-album")
  
  for (index in seq_along(artists_1_50)) {
    # Extract title
    title_element <- artists_1_50[[index]]$findChildElements("css selector", ".c-gallery-vertical-album__title")
    title <- sapply(title_element, function(x) unlist(x$getElementText()))
    
    # Extract number
    number_element <- artists_1_50[[index]]$findChildElements("css selector", ".c-gallery-vertical-album__number")
    number <- sapply(number_element, function(x) unlist(x$getElementText()))
    
    # Add to the data frame
    artists_data <- rbind(artists_data, data.frame(rank = number, artist = title, stringsAsFactors = FALSE))
  }
  
  # 3. Load more information ----------------------------------------------
  # We load the last 50 artists in the list
  load_more_button <- driver$findElement("css selector", ".c-gallery-vertical__load-button")
  if (!is.null(load_more_button)) {
      load_more_button$clickElement()
      Sys.sleep(10)  # Wait for the page to load (you may need to adjust this)
    
  # Check for a potential "Cancel" button and click it if it exists
  allow_button <- driver$findElement("css selector", ".align-right.secondary.slidedown-button")
  
  if (!is.null(allow_button)) {
  allow_button$clickElement()
  Sys.sleep(3)  # Wait for the page to load after clicking "Allow"
  } else {
  cat("Cancel button not found. Continue without clicking.\n")
  }
  
  # 4. Search and extract more results -----------------------------------
  # Extract information for the last 50 artists
  artists_50_1 <- driver$findElements("css selector", ".c-gallery-vertical-album")
  
  for (index in seq_along(artists_50_1)) {
    # Extract title
    title_element <- artists_50_1[[index]]$findChildElements("css selector", ".c-gallery-vertical-album__title")
    title <- sapply(title_element, function(x) unlist(x$getElementText()))
    
    # Extract number
    number_element <- artists_50_1[[index]]$findChildElements("css selector", ".c-gallery-vertical-album__number")
    number <- sapply(number_element, function(x) unlist(x$getElementText()))
    
    # Add to the data frame
    artists_data <- rbind(artists_data, data.frame(rank = number, artist = title, stringsAsFactors = FALSE))
  }
  
  # Close the browser
  driver$close()
  rD$server$stop()

  return(artists_data)
  }
}

# We store the output
artists_data <- get_artists()
#print(artists_data)

```


```{r}

# STEP 3. WE CREATE A FUNCTION TO CHECK FOR THE TABLES  -----------------------------------------------

# We create a function to test for the existence and dimensionality of the table
check_table <- function(inputdatabase, inputtable) {
  
  if(file.exists(paste0("./database/",inputdatabase))){
    
    database <- paste0("./database/",inputdatabase)
    con <- dbConnect(RSQLite::SQLite(), database)
    
      if (inputtable %in% dbListTables(con)) {
        # Read the table into R
        table_data <- dbReadTable(con, inputtable)
        cat('Number of rows:', nrow(table_data),'\nNumber of columns:', ncol(table_data),'\nDifferent variables in the table:', paste(colnames(table_data), collapse = ', '),'\n')
        dbDisconnect(con)
        
      } else {
        cat("Error: Table not found in file.")
      }
  }
  else{
    print("Error: File not found in folder.")
  }
} 

```

```{r, eval = FALSE}

# STEP 4. WE GET THE SPOTIFY INFORMATION -----------------------------------------------

# First, we obtain our token 

# 1. We get the access token - Need to delete this commented code with my credentials. But all of this serves to get the access token
client_id <- "005c48c3f91643aeab68ab57a84d3226"
client_secret <- "b4c14920c90045e5aa4eb528ab31cdd5"

# Create the authorization string
auth_string <- sprintf("%s:%s", client_id, client_secret)
auth_base64 <- base64enc::base64encode(charToRaw(auth_string))

# Set up the request
token_url <- "https://accounts.spotify.com/api/token"
headers <- c(
  Authorization = paste("Basic", auth_base64),
  "Content-Type" = "application/x-www-form-urlencoded"
)
body <- list(
  grant_type = "client_credentials"
)

# Make the request
response <- POST(
  url = token_url,
  add_headers(headers),
  body = body,
  encode = "form"
)

# Extract the access token
token <- content(response)$access_token

# TO DELETE - This is the access token: BQDNPOdybvMAI1lqP6Kqr6yeLJPErvhXv6mnwxKiF5EofezVgUFKUNG8mFxzcc0LMApcLjtk33HF9SMyISruh8Fp4_dBbmdJoZGLYKT0E6uMzFa4DR8 

# I assume you run this code everytime you want an access token 

```

```{r, eval=FALSE}

# Second, we get the artistis' IDs

# Function to get Spotify ID by artist name
get_artist_ids <- function(data_frame, access_token) {
  
  # 1. Setup -----------------------------------------------
  # Setup Spotify API search endpoint URL
  search_url <- "https://api.spotify.com/v1/search"
  
  # Create an empty vector to store the Spotify IDs
  artist_ids <- character()
  
  # 2. Search ----------------------------------------------
  # Iterate over each artist in the data frame
  for (name in data_frame$artist) {
    # Make a GET request to the Spotify API
    response <- GET(
      url = search_url,
      query = list(q = name, type = "artist"),
      add_headers(Authorization = paste("Bearer", access_token))
    )
    
    # 3. Extract results -----------------------------------
    # Check if the response is in JSON format
    if (http_type(response) == "application/json") {
      data <- content(response, "parsed")
      
      # Check if there are artists in the response
      if ("artists" %in% names(data)) {
        artists <- data$artists
        
        # Check if there are items in the artists response and get the first ID
        if ("items" %in% names(artists) && length(artists$items) > 0) {
          artist_ids <- c(artist_ids, artists$items[[1]]$id)
        }
      }
    }
  }
  
  # Add the 'id' column to the data frame
  data_frame$id <- artist_ids
  
  return(data_frame)
}

# Get artist IDs and update the data frame
artists_data <- get_artist_ids(artists_data, token)
#print(artists_data)

```

```{r, eval=FALSE}

# Second, we get the details for the artists

# Combined Function to get Spotify IDs and details by artist name
get_artist_details <- function(data_frame, access_token) {
  
  # 1. Setup --------------------------------------------------
  # Setup Spotify API search endpoint URL
  search_url <- "https://api.spotify.com/v1/search"
  
  # Create empty vectors to store artist details
  followers <- numeric()
  genres <- list()
  popularity <- numeric()
  
  # 2. Search -------------------------------------------------
  # Iterate over each artist in the data frame
  for (name in data_frame$artist) {
    # Make a GET request to the Spotify API
    response <- GET(
      url = search_url,
      query = list(q = name, type = "artist"),
      add_headers(Authorization = paste("Bearer", access_token))
    )
    
    # Check if the response is in JSON format
    if (http_type(response) == "application/json") {
      data <- content(response, "parsed")
      
      # Check if there are artists in the response
      if ("artists" %in% names(data)) {
        artists <- data$artists
        
        # Check if there are items in the artists response and get the first ID
        if ("items" %in% names(artists) && length(artists$items) > 0) {
          artist_id <- artists$items[[1]]$id
          
          
          # 3. Extract results ------------------------------------
          # Get artist details for each ID
          details_response <- GET(
            url = paste0("https://api.spotify.com/v1/artists/", artist_id),
            add_headers(Authorization = paste("Bearer", access_token))
          )
          
          # Check if the details response is in JSON format
          if (http_type(details_response) == "application/json") {
            details <- content(details_response, "parsed")
            
            # Extract information and append to vectors
            followers <- c(followers, details$followers$total)
            genres <- c(genres, list(details$genres))
            popularity <- c(popularity, details$popularity)
          }
        }
      }
    }
  }
  
  # Add new variables to the data frame
  data_frame$followers <- followers
  data_frame$genres <- genres
  data_frame$popularity <- popularity
  
  return(data_frame)
}

# Get artist details and update the data frame
artists_data <- get_artist_details(artists_data, token)

```


```{r, eval=FALSE}

# DATA SHAPE ----------------------------------------------

# Before continuing, we need to create different groups based on the genre of the music


# Flatten the 'genres' list into a character vector
artists_data$genres <- sapply(artists_data$genres, function(genre_list) {
  if (length(genre_list) > 0) {
    return(toString(genre_list))
  } else {
    return(NA)
  }
}, USE.NAMES = FALSE)

# Convert the 'genre' column to character type
artists_data$genres <- as.character(artists_data$genres)

# Split the genres into a list of genres
artists_data$genres <- strsplit(artists_data$genres, ', ')

# Check the different genres to divide them
#all_genres <- unique(unlist(artists_data$genre))

# We create the different groups
map_to_category <- function(genres) {
  if (any(is.na(genres))) {
    return(NA)
  } 
  
  # Count occurrences of each genre
  genre_counts <- table(unlist(genres))
  
  # Identify the genre with the maximum count
  majority_genre <- names(which.max(genre_counts))
  
  if (any(majority_genre %in% c("alternative rock", "dance rock", "funk rock", "new wave", "permanent wave", "rock", "zolo", "rock-and-roll", "rockabilly", "classic rock", "hard rock", "southern rock", "album rock", "heartland rock", "folk rock", "psychedelic rock", "blues rock", "soft rock", "industrial rock", "swamp rock", "progressive rock", "symphonic rock", "acid rock", "stoner rock", "electronic rock", "industrial", "post-grunge", "roots rock", "australian rock", "art rock", "experimental", "instrumental rock", "jam band", "mellow gold", "glam rock", "piano rock", "grunge", "irish rock", "british invasion", "merseybeat"))) {
    return("Rock")
  } else if (any(majority_genre %in% c("glam metal", "alternative metal", "birmingham metal", "uk doom metal", "thrash metal", "industrial metal", "nu metal"))) {
    return("Metal")
  } else if (any(majority_genre %in% c("punk", "art punk", "post-punk", "hardcore punk", "early us punk", "protopunk", "cyberpunk"))) {
    return("Punk")
  } else if (any(majority_genre %in% c("hip hop", "gangster rap", "pop rap", "rap", "g funk", "west coast rap", "detroit hip hop", "old school hip hop", "golden age hip hop", "old school thrash", "queens hip hop", "conscious hip hop", "hardcore hip hop", "political hip hop", "p funk", "east coast hip hop", "ganster rap"))) {
    return("Hip Hop/Rap")
  } else if (any(majority_genre %in% c("classic soul", "funk", "soul", "motown", "athens indie", "soul blues", "psychedelic soul", "neo soul", "northern soul", "jazz blues", "r&b", "instrumental soul", "chicago soul", "classic girl group", "memphis soul"))) {
    return("Soul/R&B")
  } else if (any(majority_genre %in% c("dance pop", "brill building pop", "pop", "sunshine pop", "beatlesque", "adult standards", "doo-wop", "baroque pop"))) {
    return("Pop")
  } else if (any(majority_genre %in% c("blues", "instrumental funk", "chicago blues", "delta blues", "harmonica blues", "memphis blues", "traditional blues", "electric blues", "acoustic blues", "piano blues", "jazz blues", "louisiana blues"))) {
    return("Blues")
  } else if (any(majority_genre %in% c("country", "honky tonk", "traditional country", "outlaw country", "arkansas country", "alternative country", "cosmic american", "country rock", "folk", "singer-songwriter", "canadian singer-songwriter", "cosmic american"))) {
    return("Country/Folk")
  } else if (any(majority_genre %in% c("vocal jazz", "jazz fusion", "jazz rock"))) {
    return("Jazz")
  } else if (any(majority_genre %in% c("reggae", "roots reggae"))) {
    return("Reggae")
  } else {
    return("Other")
  }
}

# Apply the mapping function to create a new 'genre_category' column
artists_data$genre_category <- sapply(artists_data$genres, map_to_category)

# Convert all columns to character - to be able to write it to the relational database
artists_data[] <- lapply(artists_data, as.character)

# Write to SQLite database
dbWriteTable(connection, "artists_data", artists_data, overwrite = TRUE, keys = 'artist')

```

```{r}
# We check the final version of 'artists_data'
check_table('finalassignment.sqlite', 'artists_data')
```

```{r, eval=FALSE}

# Third, we retrieve the data for the albums

# Combined Function to get artist details and albums by artist name
get_albums_data <- function(data_frame, access_token) {
  
  # 1. Setup ------------------------------------
  # Setup Spotify API search endpoint URL
  search_url <- "https://api.spotify.com/v1/search"

  # Create empty data frame to store albums data
  albums_data <- data.frame(
    artist = character(),
    total_tracks = numeric(),
    album_name = character(),
    release_date = character(),
    album_type = character(),
    available_markets = character(),  # Add available_markets variable
    stringsAsFactors = FALSE
  )

  # 2. Search -----------------------------------
  # Iterate over each artist in the data frame
  for (i in seq(nrow(data_frame))) {
    artist <- data_frame$artist[i]

    # Make a GET request to the Spotify API
    response <- GET(
      url = search_url,
      query = list(q = artist, type = "artist"),
      add_headers(Authorization = paste("Bearer", access_token))
    )

    # Check if the response is in JSON format
    if (http_type(response) == "application/json") {
      data <- content(response, "parsed")

      # Check if there are artists in the response
      if ("artists" %in% names(data)) {
        artists <- data$artists

        # Check if there are items in the artists response and get the first ID
        if ("items" %in% names(artists) && length(artists$items) > 0) {
          artist_id <- artists$items[[1]]$id
          
          # 3. Extract results ----------------------------------
          # Get albums data for the artist
          artist_albums_response <- GET(
            url = paste0("https://api.spotify.com/v1/artists/", artist_id, "/albums?include_groups=album,single"),
            add_headers(Authorization = paste("Bearer", access_token))
          )

          # Check if the albums response is in JSON format
          if (http_type(artist_albums_response) == "application/json") {
            artist_albums <- content(artist_albums_response, "parsed")

            # Extract relevant information and append to albums data frame
            if (!is.null(artist_albums$items)) {
              for (album in artist_albums$items) {
                albums_data <- rbind(
                  albums_data,
                  data.frame(
                    artist = artist,
                    total_tracks = album$total_tracks,
                    album_name = album$name,
                    release_date = album$release_date,
                    album_type = album$album_group,
                    available_markets = toString(album$available_markets),  # Extract available_markets
                    stringsAsFactors = FALSE
                  )
                )
              }
            }
          }
        }
      }
    }
  }

  return(albums_data)
}

# Get albums data and store it in the 'albums_data' data frame
albums_data <- get_albums_data(artists_data, token)

# We write this new table to our relational database
dbWriteTable(connection, "albums_data", albums_data, overwrite = TRUE, keys='artist')

```

```{r}
# We check it
check_table('finalassignment.sqlite', 'albums_data')
```



```{r, eval=FALSE}

# Fourth, we retrieve the data for the top tracks

# Combined Function to get top tracks by artist name
get_top_tracks_data <- function(data_frame, access_token) {
  
  # 1. Setup --------------------------------
  # Create an empty data frame to store top tracks data
  top_tracks_data <- data.frame(
    artist = character(),
    track_name = character(),
    track_popularity = numeric(),
    album_name = character(),
    stringsAsFactors = FALSE
  )

  # 2. Search --------------------------------
  # Iterate over each artist in the data frame
  for (i in seq(nrow(data_frame))) {
    artist <- data_frame$artist[i]
    artist_id <- data_frame$id[i]

    # 3. Extract results ----------------------------------
    # Get top tracks data for the artist
    artist_top_tracks_response <- GET(
      url = paste0("https://api.spotify.com/v1/artists/", artist_id, "/top-tracks?country=US"),
      add_headers(Authorization = paste("Bearer", access_token))
    )

    # Check if the top tracks response is in JSON format
    if (http_type(artist_top_tracks_response) == "application/json") {
      artist_top_tracks <- content(artist_top_tracks_response, "parsed")

      # Extract relevant information and add to the top tracks data frame
      if (!is.null(artist_top_tracks$tracks)) {
        for (track in artist_top_tracks$tracks) {
          top_tracks_data <- rbind(
            top_tracks_data,
            data.frame(
              artist = artist,
              track_name = track$name,
              track_popularity = track$popularity,
              album_name = track$album$name,
              stringsAsFactors = FALSE
            )
          )
        }
      }
    }
  }

  return(top_tracks_data)
}

# Get top tracks data and store it in the 'top_tracks_data' data frame
top_tracks_data <- get_top_tracks_data(artists_data, token)

# We write this new table to our relational database
dbWriteTable(connection, "top_tracks_data", top_tracks_data, overwrite = TRUE, keys='artist')

```

```{r}
# We check it
check_table('finalassignment.sqlite', 'top_tracks_data')
```

To add originality to the work, information has also been obtained from two other sources:

3) **Grammy Awards**: It may be interesting to know how many times an artist has won or been nominated for one of these awards. Since they are considered the most important in the music world, it makes sense that receiving one of them could influence an artist's success. Artists not found on the website are still included in the dataframe but with NA values.
4) **Wikipedia**: We obtain information about the nationality of the artists and also about the number of years they have been active. For the former, we extract information from the main Wikipedia table found under the title 'Origin' or 'Born,' and include it in our 'country' variable. For the latter, we clean the data through regular expressions found under 'Years Active' and sum the total years in the 'Total_activity' variable.

The structure of the tables is as follows:

```{r, eval=FALSE}

# STEP 5. WE GET GRAMMY AWARDS DATA -----------------------------------------

# We construct the function to get the wins and nominations
get_awards <- function(artists_data) {
  
  # 1. Setup ------------------------------------------
  # Create a data frame with the extracted information
  awards_data <- data.frame(
    artist = character(),
    wins = numeric(),
    nominations = numeric(),
    stringsAsFactors = FALSE
  )
  
  # Start a Selenium server
  rD <- rsDriver(browser = "firefox", verbose = FALSE, port = netstat::free_port(random = TRUE), chromever = NULL) 
  driver <- rD[["client"]] 
  
  # Navigate to the Grammy Awards website
  driver$navigate("https://www.grammy.com/")
  
  Sys.sleep(3)
  
  # Find and click the "Accept All" button
  accept_all_button <- driver$findElement("css selector", '.osano-cm-accept-all')
  if (!is.null(accept_all_button)) {
    accept_all_button$clickElement()
    Sys.sleep(3)
  }
  
  # Handle pop-up/modal (if it exists)
  pop_up <- tryCatch(
    driver$findElement("css selector", '.mc-closeModal'),
    error = function(e) NULL
  )
  
  if (!is.null(pop_up)) {
    # Close the pop-up by clicking the button
    pop_up$clickElement()
  }
  
  # 2. Search ------------------------------------------
  # Loop through each artist in the dataframe
  for (i in 1:nrow(artists_data)) {
    
    # Find and click the search input field
    search_input <- driver$findElement("xpath", '/html/body/div[3]/div/div/div/div/input')
    search_input$clickElement()
    
    Sys.sleep(10)
    
    # Handle pop-up/modal (if it exists)
    pop_up <- tryCatch(
      driver$findElement("css selector", '.mc-closeModal'),
      error = function(e) NULL
    )
    
    if (!is.null(pop_up)) {
      # Close the pop-up by clicking the button
      pop_up$clickElement()
    }
    
    Sys.sleep(3)
    
    # Re-find the search input after the interaction
    search_input <- driver$findElement("css selector", '.form-node')
    search_input$clickElement()

    # Enter the artist name in the search input field
    artist_name <- artists_data$artist[i]
    search_input$sendKeysToElement(list(artist_name))
      
    # Wait for the search results to load
    Sys.sleep(10)
    
    # Click on the first search result (assuming it is the artist page)
    first_result <- tryCatch(
      driver$findElement("xpath", '//*[@id="__next"]/div/div/div/div/div[6]/div/div[2]/div/div[1]/ul/li/article/div/div[2]/div[1]/div/h2/a'),
      error = function(e) NULL
    )
    
    # If the first result is not found, try a more flexible search
    if (is.null(first_result)) {
      # Clear the search input field
      search_input$clearElement()
      
      # Try an alternative search with variations in the artist's name
      alternative_names <- c(artist_name, gsub("The ", "", artist_name))
      for (alt_name in alternative_names) {
        # Clear the search input field before trying each alternative name
        search_input$clearElement()
        search_input$sendKeysToElement(list(alt_name))
        Sys.sleep(10)
        first_result <- tryCatch(
          driver$findElement("xpath", '//*[@id="__next"]/div/div/div/div/div[6]/div/div[2]/div/div[1]/ul/li/article/div/div[2]/div[1]/div/h2/a'),
          error = function(e) NULL
        )
        if (!is.null(first_result)) {
          break  # Exit the loop if a match is found
        }
      }
    }
    
    if (is.null(first_result)) {
      # Skip to the next iteration of the loop if no match is found
      next
    }
    
    # Click on the first search result
    first_result$clickElement()
    
    # Wait for the artist page to load
    Sys.sleep(3)
    
    # 3. Extract results ------------------------------------------
    # Extract and convert the number for wins using XPath in one line
    wins <- as.numeric(gsub("\\D", "", driver$findElement("xpath", '//*[@id="__next"]/div/main/section/div[2]/div[2]/div[3]/div[1]/h1')$getElementText()))
    
    # Extract and convert the number for nominations using XPath in one line
    nominations <- as.numeric(gsub("\\D", "", driver$findElement("xpath", '//*[@id="__next"]/div/main/section/div[2]/div[2]/div[3]/div[2]/h1')$getElementText()))
      
    # Append data to the awards_data data frame
    artist_info <- data.frame(artist = artist_name, wins = as.numeric(wins), nominations = as.numeric(nominations))
    awards_data <- rbind(awards_data, artist_info)
    
  }
  
  # Close the remote driver
  driver$close()
  
  return(awards_data)
}

# We call the function
awards_data <- get_awards(artists_data)

# DATA SHAPE -----------------------------------------
# 1) Get only one table with all the artists
# We create a table where we join this information with the list of 100 artists
awards_alldata <- data.frame(artists_data$artist)
colnames(awards_alldata) <- 'artist'

# We merge data frames based on the "artist" column (perform a left join)
awards_data <- merge(awards_alldata, awards_data, by = "artist", all.x = TRUE)

# We replace NAs in the wins and nominations columns with 0
awards_data <- awards_data %>%
  mutate(
    wins = ifelse(is.na(wins), NA, wins),
    nominations = ifelse(is.na(nominations), NA, nominations)
  )


# 2) We correct some wrong values
# Correct values for 'The Ramones'
awards_data$wins[awards_data$artist == 'The Ramones'] <- NA
awards_data$nominations[awards_data$artist == 'The Ramones'] <- NA

# Correct values for 'U2'
awards_data$wins[awards_data$artist == 'U2'] <- 22
awards_data$nominations[awards_data$artist == 'U2'] <- 46


# We write this new table to our relational database
dbWriteTable(connection, "awards_data", awards_data, overwrite = TRUE, keys='artist')


```

```{r}
# We check it
check_table('finalassignment.sqlite', 'awards_data')
```


```{r, eval=FALSE}

# STEP 6. WE GET WIKIPEDIA DATA ----------------------------------

get_wikidata <- function(artist_data) {
  
  # 1. Setup ------------------------------------
  # Create an empty data frame to store top tracks data
  wikipedia_data <- data.frame(
    artist = character(),
    country = character(),
    activity = character(),
    stringsAsFactors = FALSE
  )
  
  # 2. Search -----------------------------------
  for (artist in artist_data$artist) {
    
    # Specify the URL of the Wikipedia page using a general expression
    if (artist == "Guns n’ Roses") {
      wiki_url <- "https://en.wikipedia.org/wiki/Guns_N%27_Roses"
    } else if (artist == "Parliament and Funkadelic") {
      wiki_url <- "https://en.wikipedia.org/wiki/Parliament-Funkadelic"
    } else if (artist == "Nirvana") {
      wiki_url <- "https://en.wikipedia.org/wiki/Nirvana_(band)"
    } else if (artist == "Queen") {
      wiki_url <- "https://en.wikipedia.org/wiki/Queen_(band)"
    } else if (artist == "Prince") {
      wiki_url <- "https://en.wikipedia.org/wiki/Prince_(musician)"
    } else {
      # For other artists, handle the name format as before
      if (length(strsplit(artist, " ")[[1]]) == 1) {
        # If it is only one word, use the artist name as is
        wiki_url <- paste0("https://en.wikipedia.org/wiki/", artist)
      } else {
        # If it is more than two words, separate the letters by _
        wiki_url <- paste0("https://en.wikipedia.org/wiki/", gsub(" ", "_", artist))
      }
    }
    
    # Try to read the HTML content of the webpage
    tryCatch({
      page <- read_html(wiki_url)
      
      # Extract all tables from the page
      tables <- html_table(page, fill = TRUE)
      
      labels <- page %>% html_elements(css = ".infobox-label") %>% html_text()
      info <- page %>% html_elements(css = ".infobox-data") %>% html_text()
      
      # 3. Extract results --------------------------------
      # Check if label "Origin" is present
      if ("Origin" %in% labels) {
        country <- info[labels == 'Origin']
      } else if ("Born" %in% labels) {
        # If "Origin" is not found, check if "Born" is present
        born_label <- info[labels == 'Born']
        # Extract last two words from "Born" label
        location <- unlist(strsplit(born_label, "\\s+"))
        country <- paste(tail(location, 2), collapse = " ")
      } else {
        # If neither "Origin" nor "Born" is present, assign NA to "Country"
        country <- NA
      }
      
      if ("Years active" %in% labels) {
        activity <- info[labels == 'Years active']
      } else {
        activity <- NA
      }
      
      # Append data to the location_data data frame
      artist_info <- data.frame(artist = artist, country = country, activity = activity)
      wikipedia_data <- rbind(wikipedia_data, artist_info)
    }, error = function(e) {
      cat("Error for artist:", artist, "\n")
    })
  }
  
  return(wikipedia_data)
}

# We call the function
wikipedia_data <- get_wikidata(artists_data)


# DATA SHAPE -----------------------------------


# Function to calculate total years of activity for each observation
calculate_total_activity <- function(activity_string) {
  
  # Check if activity_string is NA
  if (is.na(activity_string)) {
    return(NA)
  }

  # Replace 'present' with '2023'
  activity_string <- gsub("present", "2023", activity_string, ignore.case = TRUE)
  
  # Remove content inside square brackets
  activity_string <- gsub("\\[.*?\\]", "", activity_string)
  
  # Remove content inside parentheses
  activity_string <- gsub("\\(.*?\\)", "", activity_string)
  
  # Add space between four consecutive digits
  activity_string <- gsub("(\\d{4})", "\\1 ", activity_string)
  
  # Extract all substrings that look like pairs of years separated by '-' or ','
  year_pairs <- str_extract_all(activity_string, "\\b\\d{4}\\b\\s*(?:–|,)\\s*\\b\\d{4}\\b")[[1]]
  
  # If no pairs found, return 0
  if (length(year_pairs) == 0) {
    return(0)
  }
  
  # Initialize total years
  total_years <- 0
  
  # Iterate over each pair of years
  for (pair in year_pairs) {
    # Extract individual years from the pair
    years <- str_extract_all(pair, "\\d{4}")[[1]]
    
    # Convert years to numeric
    years <- as.numeric(years)
    
    # Calculate the difference between consecutive years and add to the total
    total_years <- total_years + sum(diff(years))
  }
  
  return(total_years)
}

# Apply the function to each observation in the 'activity' column
wikipedia_data$total_activity <- sapply(wikipedia_data$activity, calculate_total_activity)

# We write this new table to our relational database
dbWriteTable(connection, "wikipedia_data", wikipedia_data, overwrite = TRUE, keys='artist')

```

```{r}
# We check it
check_table('finalassignment.sqlite', 'wikipedia_data')
```


# 3. Analysis {#exercise-3}

For the analysis, we mixed the tables that we have stored in our SQLite database all together. For the purposes how our analysis we create two different tables:


```{r}
# We open the connection once again
connection <- dbConnect(RSQLite::SQLite(), mydatabase)

# Drop if exists
dbExecute(connection, "DROP TABLE IF EXISTS albums_final_data", verbose = FALSE)
dbExecute(connection, "DROP TABLE IF EXISTS toptracks_final_data", verbose = FALSE)


# We create a combined table for albums data
dbExecute(connection, "
CREATE TABLE albums_final_data AS
SELECT 
    ad.artist,
    ad.rank,
    ad.followers / 1000000 AS followers_in_millions,
    CAST(ad.popularity AS INTEGER) AS popularity,
    ad.genre_category,
    al.total_tracks,
    al.album_name,
    al.release_date,
    al.album_type,
    al.available_markets,
    aw.wins,
    aw.nominations,
    wd.country,
    wd.total_activity
FROM artists_data ad
LEFT JOIN albums_data al ON ad.artist = al.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist;
")

# Retrieve the table
albums_final_data <- dbGetQuery(connection, "SELECT * FROM albums_final_data")
```

**Table 1: Albums Final Data**
```{r}
# Print the head(3) entries
print(names(albums_final_data))
```


```{r}
# We create another combined table for top tracks data 
dbExecute(connection, "
CREATE TABLE toptracks_final_data AS
SELECT 
    ad.artist,
    ad.rank,
    ad.followers / 1000000 AS followers_in_millions,
    CAST(ad.popularity AS INTEGER) AS popularity,
    ad.genre_category,
    tt.track_name,
    tt.track_popularity,
    tt.album_name,
    al.release_date,  
    aw.wins,
    aw.nominations,
    wd.country,
    wd.total_activity
FROM artists_data ad
LEFT JOIN top_tracks_data tt ON ad.artist = tt.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist
LEFT JOIN albums_data al ON tt.album_name = al.album_name;  
")

# Retrieve the table
toptracks_final_data <- dbGetQuery(connection, "SELECT * FROM toptracks_final_data")


```

**Table 2: Top Tracks Final Data**
```{r}
# Print the head(3) entries
print(names(toptracks_final_data))
```

Some changes that will be done before starting the analysis include:

* Adding a variable called **'year'** where the year each album was released is established.
* Constructing another variable **'decade'** to analyze trends more easily in the long term.
* Transforming the nationality of the artists into ISO 3166-1 alpha-2 country codes under the variable **'origin**, as the information about the 'available_markets' from Spotify comes in that format.


## 3.1. XXXXXXXXXxx
What we see here. 

- You can have a lot of albums or singles and that does not influence your popularity. But the major amount of top tracks is linked with your popularity. That means, the more popular you are, the more top tracks you will have. 

One artist (Maria Carey) can have like one top track, and be really popular because that top track keeps coming on and on. But then, this proves that the more popular you are, then you have MORE THAN ONE top
```{r}
# 1) TOTAL ALBUMS BY AN ARTIST VS POPULARITY
# Sum the number of albums by artist
album_sum_by_artist <- albums_final_data %>%
  filter(album_type == 'album') %>%
  group_by(artist) %>%
  summarize(total_albums = n(), popularity_mean = mean(popularity))

# Create an interactive scatter plot with Plotly
albums_popularity <- plot_ly(
  data = album_sum_by_artist,
  x = ~popularity_mean,
  y = ~total_albums,
  text = ~artist,  # Display artist name on hover/click
  color = ~popularity_mean,
  type = "scatter",
  mode = "markers"
) %>%
  layout(
    title = "Popularity vs Total Number of Albums",
    xaxis = list(title = "Popularity (Mean)"),
    yaxis = list(title = "Total Number of Albums"),
    coloraxis = list(colorscale = "Viridis")
  )

# 2) TOTAL SINGLES BY AN ARTIST VS POPULARITY
# Sum the number of singles by artist
single_sum_by_artist <- albums_final_data %>%
  filter(album_type == 'single') %>%
  group_by(artist) %>%
  summarize(total_singles = n(), popularity_mean = mean(popularity))

# Create an interactive scatter plot with Plotly
singles_popularity <- plot_ly(
  data = single_sum_by_artist,
  x = ~popularity_mean,
  y = ~total_singles,  # Adjust to use the correct variable
  text = ~artist,  # Display artist name on hover/click
  color = ~popularity_mean,
  type = "scatter",
  mode = "markers"
) %>%
  layout(
    title = "Popularity vs Total Number of Singles",
    xaxis = list(title = "Popularity (Mean)"),
    yaxis = list(title = "Total Number of Singles"),
    coloraxis = list(colorscale = "Viridis")
  )


# 3) TOP TRACKS WITH POP > 60 AGAINST ARTIST POPULARITY
# Filter top tracks with track_popularity > 60
filtered_toptracks <- toptracks_final_data %>%
  filter(track_popularity > 75)

# Sum the number of top tracks by artist
toptracks_sum_by_artist <- filtered_toptracks %>%
  group_by(artist) %>%
  summarize(total_toptracks = n(), popularity_mean = mean(popularity))

# Create an interactive scatter plot with Plotly
toptracks_followers <- plot_ly(
  data = toptracks_sum_by_artist,
  x = ~popularity_mean,
  y = ~total_toptracks,
  text = ~artist,  # Display artist name on hover/click
  color = ~popularity_mean,
  type = "scatter",
  mode = "markers"
) %>%
  layout(
    title = "Artist Popularity vs Total Number of Top Tracks (Popularity > 60)",
    xaxis = list(title = "Artist Popularity (Mean)"),
    yaxis = list(title = "Total Number of Top Tracks"),
    coloraxis = list(colorscale = "Viridis")
  )


# Display both plots
albums_popularity
singles_popularity
toptracks_followers
```

```{r}
# 4) NUMBER OF LIVE AGAINST POPULARITY
# Filter albums with names containing 'Live' or 'live'
live_albums_data <- albums_final_data %>%
  filter(str_detect(album_name, "(?i)live"))

# Sum the number of observations for each artist
live_albums_sum_by_artist <- live_albums_data %>%
  group_by(artist) %>%
  summarize(total_albums = n(), popularity_mean = mean(popularity))

# Create an interactive scatter plot with Plotly
live_albums_popularity_tracks <- plot_ly(
  data = live_albums_sum_by_artist,
  x = ~popularity_mean,
  y = ~total_albums,
  text = ~artist,  # Display artist name on hover/click
  color = ~popularity_mean,
  type = "scatter",
  mode = "markers"
) %>%
  add_lines(
    x = ~popularity_mean,
    y = ~lm(total_albums ~ popularity_mean, data = live_albums_sum_by_artist)$fitted.values,
    line = list(color = 'black'),
    name = "Regression Line"
  ) %>%
  layout(
    title = "Artist Popularity vs Total 'Live' Albums",
    xaxis = list(title = "Artist Popularity"),
    yaxis = list(title = "Total Number of 'Live' Albums"),
    coloraxis = list(colorscale = "Viridis")
  )

# Print the Plotly object to the console
live_albums_popularity_tracks
```

```{r}
# 5) YEARS ACTIVE AGAINST POPULARITY
# Remove rows with NA values in 'total_activity'
cleaned_albums_data <- albums_final_data %>%
  filter(!is.na(total_activity))

# Create an interactive scatter plot with Plotly
activity_popularity <- plot_ly(
  data = cleaned_albums_data,
  x = ~popularity,
  y = ~total_activity,
  text = ~artist,  # Display artist name on hover/click
  color = ~popularity,
  type = "scatter",
  mode = "markers"
) %>%
  add_lines(
    x = ~popularity,
    y = ~lm(total_activity ~ popularity, data = cleaned_albums_data)$fitted.values,
    line = list(color = 'black'),
    name = "Regression Line"
  ) %>%
  layout(
    title = "Artist Popularity vs Total Activity",
    xaxis = list(title = "Artist Popularity"),
    yaxis = list(title = "Total Activity"),
    coloraxis = list(colorscale = "Viridis")
  )

# Print the Plotly object to the console
activity_popularity
```


## 3.3. Relationship between Awards and Popularity

The Grammy Awards recognize both artistic performance and technical excellence in the music industry. This encompasses vocal performance, instrumentation, production, and the overall quality of the recording. 

As expected, there is a really high connection between those artists winning the awards and their popularity. While not so pronounced, the situation is the same for those nominated. These results indicate that quality of the music is appreciated by the public and represents an important characteristic of why music triumphs. 

```{r}
# Remove rows with NA values in 'wins', 'nominations', and 'popularity'
cleaned_awards_data_wins <- albums_final_data %>%
  filter(!is.na(wins) & !is.na(popularity))

# Remove rows with NA values in 'nominations', 'popularity'
cleaned_awards_data_nominations <- albums_final_data %>%
  filter(!is.na(nominations) & !is.na(popularity))


# Assuming your data frame is named cleaned_awards_data_wins
mean_popularity_per_wins <- cleaned_awards_data_wins %>%
  group_by(wins) %>%
  summarise(mean_popularity = mean(popularity, na.rm = TRUE))

# Create an interactive scatter plot with Plotly (switch x and y)
scatter_plot_wins <- plot_ly(
  data = mean_popularity_per_wins,
  y = ~wins,  # Switched x and y here
  x = ~mean_popularity,  # Switched x and y here
  type = "scatter",
  mode = "markers",
  text = ~paste("Wins: ", wins, "<br>Mean Popularity: ", round(mean_popularity, 2))
) %>%
  add_lines(
    y = ~wins,  # Switched x and y here
    x = ~fitted(lm(mean_popularity ~ wins, data = mean_popularity_per_wins)),  # Switched x and y here
    type = "scatter",
    mode = "lines",
    line = list(color = "red"),
    name = "Regression Line"
  ) %>%
  layout(
    title = "Mean Popularity Based on Wins",
    xaxis = list(title = "Mean Popularity"),  # Switched x and y here
    yaxis = list(title = "Number of Wins")  # Switched x and y here
  )

# Print the Plotly object to the console
scatter_plot_wins

#_____________________________________________________
# Assuming your data frame is named cleaned_awards_data_nominations
mean_popularity_per_nominations <- cleaned_awards_data_nominations %>%
  group_by(nominations) %>%
  summarise(mean_popularity = mean(popularity, na.rm = TRUE))

# Create an interactive scatter plot with Plotly (switch x and y)
scatter_plot_nominations <- plot_ly(
  data = mean_popularity_per_nominations,
  y = ~nominations,  # Switched x and y here
  x = ~mean_popularity,  # Switched x and y here
  type = "scatter",
  mode = "markers",
  text = ~paste("Nominations: ", nominations, "<br>Mean Popularity: ", round(mean_popularity, 2))
) %>%
  add_lines(
    y = ~nominations,  # Switched x and y here
    x = ~fitted(lm(mean_popularity ~ nominations, data = mean_popularity_per_nominations)),  # Switched x and y here
    type = "scatter",
    mode = "lines",
    line = list(color = "red"),
    name = "Regression Line"
  ) %>%
  layout(
    title = "Mean Popularity Based on Nominations",
    xaxis = list(title = "Mean Popularity"),  # Switched x and y here
    yaxis = list(title = "Number of Nominations")  # Switched x and y here
  )

# Print the Plotly object to the console
scatter_plot_nominations
```

The following graphs gives further an more particular information. They show, in an individual way, how many wins and nominations has received each artist, plotted against its popularity. 
```{r}
# X) Create an interactive scatter plot with Plotly for Wins
wins_plot <- plot_ly(
  data = cleaned_awards_data_wins,
  x = ~popularity,
  y = ~wins,
  text = ~artist,  # Display artist name on hover/click
  color = ~wins,
  type = "scatter",
  mode = "markers"
) %>%
  layout(
    title = "Artist Popularity vs Wins",
    xaxis = list(title = "Artist Popularity"),
    yaxis = list(title = "Wins"),
    coloraxis = list(colorscale = "Viridis")
  )

# Print the Plotly object to the console
wins_plot

# X) Create an interactive scatter plot with Plotly for Nominations
nominations_plot <- plot_ly(
  data = cleaned_awards_data_nominations,
  x = ~popularity,
  y = ~nominations,
  text = ~artist,  # Display artist name on hover/click
  color = ~nominations,
  type = "scatter",
  mode = "markers"
) %>%
  layout(
    title = "Artist Popularity vs Nominations",
    xaxis = list(title = "Artist Popularity"),
    yaxis = list(title = "Nominations"),
    coloraxis = list(colorscale = "Viridis")
  )

# Print the Plotly object to the console
nominations_plot


# Assuming your data frame is named albums_final_data
correlation_matrix <- albums_final_data %>%
  select(wins, nominations, followers_in_millions, popularity) %>%
  na.omit() %>%
  cor()

# Create an interactive heatmap for the correlation matrix
# Create an interactive heatmap for the correlation matrix with a reverse color scale
plot_ly(z = ~correlation_matrix, colorscale = "YlGnBu", reversescale = TRUE, type = "heatmap", 
        x = colnames(correlation_matrix), y = colnames(correlation_matrix),
        text = ~paste("Correlation: ", round(correlation_matrix, 2))) %>%
  layout(title = "Correlation Matrix: Wins, Nominations, Followers, Popularity",
         xaxis = list(title = "Variables"),
         yaxis = list(title = "Variables"))
```

## 3.4. Evolution of Music Genra over the years

```{r}
# 7) GENRE THROUGHOUT THE YEARS

# Convert 'release_date' to year
albums_final_data$year <- as.numeric(substr(albums_final_data$release_date, 1, 4))

# Calculate the percentage of times each genre appears over the total observations in each year
genre_percentage <- albums_final_data %>%
  group_by(year, genre_category) %>%
  summarize(percentage = n() / nrow(albums_final_data) * 100) %>%
  filter(!is.na(percentage) & !is.na(genre_category))  # Remove rows with NAs in the percentage or genre_category columns

# Create a line plot for genre percentage over the years
line_plot <- ggplot(genre_percentage, aes(x = year, y = percentage, color = genre_category)) +
  geom_line() +
  labs(
    title = "Percentage of Times Each Genre Appears Over Time",
    x = "Year",
    y = "Percentage"
  ) +
  theme_minimal()

# Convert the ggplot object to an interactive plot with Plotly
line_plot_interactive <- ggplotly(line_plot)

# Print the interactive Plotly object to the console
line_plot_interactive
```

Here, we should highlight how important Bob Marley was for Reggae and how importat was Patti Smith for Punk. 
```{r}
# 8) GENRE CATEGORY VS POPULARITY
# Filter out 'Punk', 'Reggae', and NA values from genre_category
filtered_data <- albums_final_data %>%
  filter(!is.na(genre_category))

# Create an interactive boxplot with genres (excluding 'Punk', 'Reggae', and NA) filled by popularity using plot_ly
boxplot_interactive_filtered <- plot_ly(
  x = ~genre_category,
  y = ~popularity,
  data = filtered_data,
  type = "box",
  boxpoints = "all",
  jitter = 0.3,
  pointpos = -1.8,
  color = ~genre_category,
  colors = c(
  'blue', 'orange', 'green', 'red', 'purple',
  'brown', 'pink', 'gray', 'yellow', 'cyan', 'darkblue'),
  opacity = 0.7
) %>%
  layout(
    title = "Boxplot of Popularity by Genre",
    xaxis = list(title = "Genre"),
    yaxis = list(title = "Popularity"),
    showlegend = FALSE
  )

# Print the interactive Plotly object to the console
boxplot_interactive_filtered
```

```{r}
# 11) TOP TRACKS THROUGHOUT TIME

# Convert 'release_date' to year
toptracks_final_data$year <- as.numeric(substr(toptracks_final_data$release_date, 1, 4))

toptracks_final_data$decade <- cut(toptracks_final_data$year, breaks = c(1960, 1970, 1980, 1990, 2000, 2010, 2020), labels = c("1960-1970", "1970-1980", "1980-1990", "1990-2000", "2000-2010", "2010-2020"))


# Assuming your data frame is named toptracks_final_data
toptracks_final_data_filter <- toptracks_final_data %>%
  arrange(desc(track_popularity)) %>%
  group_by(decade) %>%
  slice_head(n = 10) %>%
  ungroup()

# Assuming your data frame is named toptracks_final_data_filter
genre_count_per_decade <- toptracks_final_data_filter %>%
  count(decade, genre_category, name = "genre_count")

# Calculate percentage within each decade
genre_count_per_decade <- genre_count_per_decade %>%
  group_by(decade) %>%
  mutate(percentage = genre_count / sum(genre_count) * 100)

# Create an interactive bar plot
plot_ly(genre_count_per_decade, x = ~decade, y = ~genre_count, color = ~genre_category, type = "bar", text = ~paste(genre_category, sprintf("%.2f%%", percentage), "<br>", genre_count)) %>%
  layout(title = "Number of Tracks for Each Genre in Every Decade",
         xaxis = list(title = "Decade"),
         yaxis = list(title = "Number of Tracks"),
         barmode = "stack")

# Assuming your data frame is named toptracks_final_data_plot
top_tracks_tables <- toptracks_final_data_filter %>%
  filter(!is.na(decade)) %>%  # Exclude rows where decade is NA
  group_by(decade) %>%
  slice_head(n = 5) %>%
  select(decade, genre_category, track_name, artist, popularity) %>%
  ungroup()

# Print the resulting tables
print(top_tracks_tables)
```


## 3.5. Predominant nationalities in music

```{r}
# 9) ARTISTS BY NATIONALITY

# Function to extract the last word from a location string
extract_last_word <- function(location) {
  words <- unlist(strsplit(location, ",\\s*"))
  last_word <- words[length(words)]
  return(last_word)
}

# Apply the function to create a new variable in albums_final_data
albums_final_data$origin <- sapply(albums_final_data$country, extract_last_word)

# Map specific conditions
albums_final_data$origin <- ifelse(albums_final_data$origin %in% c("U.S.", "US", "Rhode Island[1]: 24 New York City", "United States", "California", "Tennessee"), "US", ifelse(albums_final_data$origin %in% c("Northern Ireland", "England"), "GB", ifelse(albums_final_data$origin %in% c("Canada"), "CA", ifelse(albums_final_data$origin %in% c("Australia"), "AU", ifelse(albums_final_data$origin %in% c("Jamaica"), "JM", ifelse(albums_final_data$origin %in% c("Ireland"), "IE",albums_final_data$origin))))))

# Filter out rows with NAs in 'origin' or 'available_markets'
filtered_data <- albums_final_data %>% filter(!is.na(origin) & !is.na(available_markets))

# Get unique origins and available markets
selected_origins <- unique(filtered_data$origin)
selected_markets <- unique(unlist(strsplit(filtered_data$available_markets, ", ")))

# Filter world map data for selected origins and markets
world <- ne_countries(returnclass = "sf")

# Create a color column based on 'origin' and 'available_markets'
world_colors <- world %>%
  mutate(color = ifelse(iso_a2 %in% selected_origins, "red", 
                        ifelse(iso_a2 %in% selected_markets, "blue", "white")))

# Create the leaflet map
map <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = world_colors, 
              fillColor = ~color, 
              fillOpacity = 0.5, 
              popup = ~name,
              stroke = FALSE) %>%
  setView(lng = -95, lat = 37, zoom = 2)

# Show the map
map
```

```{r}
# Assuming 'albums_final_data' is the name of your combined table for albums
# Filter unique artists
unique_artists <- albums_final_data %>%
  distinct(artist, .keep_all = TRUE)

# Remove NAs from the 'origin' column
unique_artists <- unique_artists[!is.na(unique_artists$origin), ]

# Compute the proportion of times each 'origin' appears
country_proportions <- unique_artists %>%
  group_by(origin) %>%
  summarize(proportion = n() / nrow(unique_artists) * 100) %>%
  arrange(desc(proportion))

pie_chart <- ggplot(country_proportions, aes(x = "", y = proportion, fill = origin)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y") +
  geom_text(aes(label = paste0(round(proportion, 2), "%")), position = position_stack(vjust = 0.5)) +
  labs(title = "Proportion of Countries in the Dataset over 100 Artists") +
  theme_void()

# Print the ggplot object to the console
print(pie_chart)
```




# 4. Code Appendix {#exercise-4}


## Appendix: All code in this assignment

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} 

```



# 5. DOUBTS AND THINGS TO STILL DO 
5. When I do the analysis: Check if I should better create a new variable already in the albums_data called 'year', instead of here
6. Shape the plots for the awards - other things depending on wins and nominations
7. Get the correct bubble plot for the nationalities
8. Compare the number of followers - It does not match with what I get 
10.Ocultar las keys para las APIS antes de subirlo
11. Check to close the connection in the function when retrieving albums_data

BIG DOUBTS: Followers number and Keys 