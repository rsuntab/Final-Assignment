}
}
}
}
return(top_tracks_data)
}
# Get top tracks data and store it in the 'top_tracks_data' data frame
top_tracks_data <- get_top_tracks_data(artists_data, token)
# We write this new table to our relational database
dbWriteTable(connection, "top_tracks_data", top_tracks_data, overwrite = TRUE, keys='artist')
# We check it
check_table('finalassignment.sqlite', 'top_tracks_data')
# STEP 5. WE GET GRAMMY AWARDS DATA -----------------------------------------
# We construct the function to get the wins and nominations
get_awards <- function(artists_data) {
# 1. Setup ------------------------------------------
# Create a data frame with the extracted information
awards_data <- data.frame(
artist = character(),
wins = numeric(),
nominations = numeric(),
stringsAsFactors = FALSE
)
# Start a Selenium server
rD <- rsDriver(browser = "firefox", verbose = FALSE, port = netstat::free_port(random = TRUE), chromever = NULL)
driver <- rD[["client"]]
# Navigate to the Grammy Awards website
driver$navigate("https://www.grammy.com/")
Sys.sleep(3)
# Find and click the "Accept All" button
accept_all_button <- driver$findElement("css selector", '.osano-cm-accept-all')
if (!is.null(accept_all_button)) {
accept_all_button$clickElement()
Sys.sleep(3)
}
# Handle pop-up/modal (if it exists)
pop_up <- tryCatch(
driver$findElement("css selector", '.mc-closeModal'),
error = function(e) NULL
)
if (!is.null(pop_up)) {
# Close the pop-up by clicking the button
pop_up$clickElement()
}
# 2. Search ------------------------------------------
# Loop through each artist in the dataframe
for (i in 1:nrow(artists_data)) {
# Find and click the search input field
search_input <- driver$findElement("xpath", '/html/body/div[3]/div/div/div/div/input')
search_input$clickElement()
Sys.sleep(10)
# Handle pop-up/modal (if it exists)
pop_up <- tryCatch(
driver$findElement("css selector", '.mc-closeModal'),
error = function(e) NULL
)
if (!is.null(pop_up)) {
# Close the pop-up by clicking the button
pop_up$clickElement()
}
Sys.sleep(3)
# Re-find the search input after the interaction
search_input <- driver$findElement("css selector", '.form-node')
search_input$clickElement()
# Enter the artist name in the search input field
artist_name <- artists_data$artist[i]
search_input$sendKeysToElement(list(artist_name))
# Wait for the search results to load
Sys.sleep(10)
# Click on the first search result (assuming it is the artist page)
first_result <- tryCatch(
driver$findElement("xpath", '//*[@id="__next"]/div/div/div/div/div[6]/div/div[2]/div/div[1]/ul/li/article/div/div[2]/div[1]/div/h2/a'),
error = function(e) NULL
)
# If the first result is not found, try a more flexible search
if (is.null(first_result)) {
# Clear the search input field
search_input$clearElement()
# Try an alternative search with variations in the artist's name
alternative_names <- c(artist_name, gsub("The ", "", artist_name))
for (alt_name in alternative_names) {
# Clear the search input field before trying each alternative name
search_input$clearElement()
search_input$sendKeysToElement(list(alt_name))
Sys.sleep(10)
first_result <- tryCatch(
driver$findElement("xpath", '//*[@id="__next"]/div/div/div/div/div[6]/div/div[2]/div/div[1]/ul/li/article/div/div[2]/div[1]/div/h2/a'),
error = function(e) NULL
)
if (!is.null(first_result)) {
break  # Exit the loop if a match is found
}
}
}
if (is.null(first_result)) {
# Skip to the next iteration of the loop if no match is found
next
}
# Click on the first search result
first_result$clickElement()
# Wait for the artist page to load
Sys.sleep(3)
# 3. Extract results ------------------------------------------
# Extract and convert the number for wins using XPath in one line
wins <- as.numeric(gsub("\\D", "", driver$findElement("xpath", '//*[@id="__next"]/div/main/section/div[2]/div[2]/div[3]/div[1]/h1')$getElementText()))
# Extract and convert the number for nominations using XPath in one line
nominations <- as.numeric(gsub("\\D", "", driver$findElement("xpath", '//*[@id="__next"]/div/main/section/div[2]/div[2]/div[3]/div[2]/h1')$getElementText()))
# Append data to the awards_data data frame
artist_info <- data.frame(artist = artist_name, wins = as.numeric(wins), nominations = as.numeric(nominations))
awards_data <- rbind(awards_data, artist_info)
}
# Close the remote driver
driver$close()
return(awards_data)
}
# We call the function
awards_data <- get_awards(artists_data)
# DATA SHAPE -----------------------------------------
# 1) Get only one table with all the artists
# We create a table where we join this information with the list of 100 artists
awards_alldata <- data.frame(artists_data$artist)
colnames(awards_alldata) <- 'artist'
# We merge data frames based on the "artist" column (perform a left join)
awards_data <- merge(awards_alldata, awards_data, by = "artist", all.x = TRUE)
# We replace NAs in the wins and nominations columns with 0
awards_data <- awards_data %>%
mutate(
wins = ifelse(is.na(wins), NA, wins),
nominations = ifelse(is.na(nominations), NA, nominations)
)
# 2) We correct some wrong values
# Correct values for 'The Ramones'
awards_data$wins[awards_data$artist == 'The Ramones'] <- NA
awards_data$nominations[awards_data$artist == 'The Ramones'] <- NA
# Correct values for 'U2'
awards_data$wins[awards_data$artist == 'U2'] <- 22
awards_data$nominations[awards_data$artist == 'U2'] <- 46
# We write this new table to our relational database
dbWriteTable(connection, "awards_data", awards_data, overwrite = TRUE, keys='artist')
# We check it
check_table('finalassignment.sqlite', 'awards_data')
# STEP 6. WE GET WIKIPEDIA DATA ----------------------------------
get_wikidata <- function(artist_data) {
# 1. Setup ------------------------------------
# Create an empty data frame to store top tracks data
wikipedia_data <- data.frame(
artist = character(),
country = character(),
activity = character(),
stringsAsFactors = FALSE
)
# 2. Search -----------------------------------
for (artist in artist_data$artist) {
# Specify the URL of the Wikipedia page using a general expression
if (artist == "Guns n’ Roses") {
wiki_url <- "https://en.wikipedia.org/wiki/Guns_N%27_Roses"
} else if (artist == "Parliament and Funkadelic") {
wiki_url <- "https://en.wikipedia.org/wiki/Parliament-Funkadelic"
} else if (artist == "Nirvana") {
wiki_url <- "https://en.wikipedia.org/wiki/Nirvana_(band)"
} else if (artist == "Queen") {
wiki_url <- "https://en.wikipedia.org/wiki/Queen_(band)"
} else if (artist == "Prince") {
wiki_url <- "https://en.wikipedia.org/wiki/Prince_(musician)"
} else {
# For other artists, handle the name format as before
if (length(strsplit(artist, " ")[[1]]) == 1) {
# If it is only one word, use the artist name as is
wiki_url <- paste0("https://en.wikipedia.org/wiki/", artist)
} else {
# If it is more than two words, separate the letters by _
wiki_url <- paste0("https://en.wikipedia.org/wiki/", gsub(" ", "_", artist))
}
}
# Try to read the HTML content of the webpage
tryCatch({
page <- read_html(wiki_url)
# Extract all tables from the page
tables <- html_table(page, fill = TRUE)
labels <- page %>% html_elements(css = ".infobox-label") %>% html_text()
info <- page %>% html_elements(css = ".infobox-data") %>% html_text()
# 3. Extract results --------------------------------
# Check if label "Origin" is present
if ("Origin" %in% labels) {
country <- info[labels == 'Origin']
} else if ("Born" %in% labels) {
# If "Origin" is not found, check if "Born" is present
born_label <- info[labels == 'Born']
# Extract last two words from "Born" label
location <- unlist(strsplit(born_label, "\\s+"))
country <- paste(tail(location, 2), collapse = " ")
} else {
# If neither "Origin" nor "Born" is present, assign NA to "Country"
country <- NA
}
if ("Years active" %in% labels) {
activity <- info[labels == 'Years active']
} else {
activity <- NA
}
# Append data to the location_data data frame
artist_info <- data.frame(artist = artist, country = country, activity = activity)
wikipedia_data <- rbind(wikipedia_data, artist_info)
}, error = function(e) {
cat("Error for artist:", artist, "\n")
})
}
return(wikipedia_data)
}
# We call the function
wikipedia_data <- get_wikidata(artists_data)
# DATA SHAPE -----------------------------------
# Function to calculate total years of activity for each observation
calculate_total_activity <- function(activity_string) {
# Check if activity_string is NA
if (is.na(activity_string)) {
return(NA)
}
# Replace 'present' with '2023'
activity_string <- gsub("present", "2023", activity_string, ignore.case = TRUE)
# Remove content inside square brackets
activity_string <- gsub("\\[.*?\\]", "", activity_string)
# Remove content inside parentheses
activity_string <- gsub("\\(.*?\\)", "", activity_string)
# Add space between four consecutive digits
activity_string <- gsub("(\\d{4})", "\\1 ", activity_string)
# Extract all substrings that look like pairs of years separated by '-' or ','
year_pairs <- str_extract_all(activity_string, "\\b\\d{4}\\b\\s*(?:–|,)\\s*\\b\\d{4}\\b")[[1]]
# If no pairs found, return 0
if (length(year_pairs) == 0) {
return(0)
}
# Initialize total years
total_years <- 0
# Iterate over each pair of years
for (pair in year_pairs) {
# Extract individual years from the pair
years <- str_extract_all(pair, "\\d{4}")[[1]]
# Convert years to numeric
years <- as.numeric(years)
# Calculate the difference between consecutive years and add to the total
total_years <- total_years + sum(diff(years))
}
return(total_years)
}
# Apply the function to each observation in the 'activity' column
wikipedia_data$total_activity <- sapply(wikipedia_data$activity, calculate_total_activity)
# We write this new table to our relational database
dbWriteTable(connection, "wikipedia_data", wikipedia_data, overwrite = TRUE, keys='artist')
# We check it
check_table('finalassignment.sqlite', 'wikipedia_data')
# We open the connection once again
connection <- dbConnect(RSQLite::SQLite(), mydatabase)
# Drop if exists
dbExecute(connection, "DROP TABLE IF EXISTS albums_final_data")
dbExecute(connection, "DROP TABLE IF EXISTS toptracks_final_data")
# We create a combined table for albums data
dbExecute(connection, "
CREATE TABLE albums_final_data AS
SELECT
ad.artist,
ad.rank,
ad.followers / 1000000 AS followers_in_millions,
CAST(ad.popularity AS INTEGER) AS popularity,
ad.genre_category,
al.total_tracks,
al.album_name,
al.release_date,
al.album_type,
al.available_markets,
#aw.wins,
#aw.nominations,
wd.country,
wd.total_activity
FROM artists_data ad
LEFT JOIN albums_data al ON ad.artist = al.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist;
")
# Drop if exists
dbExecute(connection, "DROP TABLE IF EXISTS albums_final_data")
# We create a combined table for albums data
dbExecute(connection, "
CREATE TABLE albums_final_data AS
SELECT
ad.artist,
ad.rank,
ad.followers / 1000000 AS followers_in_millions,
CAST(ad.popularity AS INTEGER) AS popularity,
ad.genre_category,
al.total_tracks,
al.album_name,
al.release_date,
al.album_type,
al.available_markets,
#aw.wins,
#aw.nominations,
wd.country,
wd.total_activity
FROM artists_data ad
LEFT JOIN albums_data al ON ad.artist = al.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist;
")
# We open the connection once again
connection <- dbConnect(RSQLite::SQLite(), mydatabase)
# Drop if exists
dbExecute(connection, "DROP TABLE IF EXISTS albums_final_data")
dbExecute(connection, "DROP TABLE IF EXISTS toptracks_final_data")
# We create a combined table for albums data
dbExecute(connection, "
CREATE TABLE albums_final_data AS
SELECT
ad.artist,
ad.rank,
ad.followers / 1000000 AS followers_in_millions,
CAST(ad.popularity AS INTEGER) AS popularity,
ad.genre_category,
al.total_tracks,
al.album_name,
al.release_date,
al.album_type,
al.available_markets,
aw.wins,
aw.nominations,
wd.country,
wd.total_activity
FROM artists_data ad
LEFT JOIN albums_data al ON ad.artist = al.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist;
")
# Retrieve the table
albums_final_data <- dbGetQuery(connection, "SELECT * FROM albums_final_data")
# We create another combined table for top tracks data
dbExecute(connection, "
CREATE TABLE toptracks_final_data AS
SELECT
ad.artist,
ad.rank,
ad.followers / 1000000 AS followers_in_millions,
CAST(ad.popularity AS INTEGER) AS popularity,
ad.genre_category,
tt.track_name,
tt.track_popularity,
tt.album_name,
al.release_date,
aw.wins,
aw.nominations,
wd.country,
wd.total_activity
FROM artists_data ad
LEFT JOIN top_tracks_data tt ON ad.artist = tt.artist
LEFT JOIN awards_data aw ON ad.artist = aw.artist
LEFT JOIN wikipedia_data wd ON ad.artist = wd.artist
LEFT JOIN albums_data al ON tt.album_name = al.album_name;
")
# Retrieve the table
toptracks_final_data <- dbGetQuery(connection, "SELECT * FROM toptracks_final_data")
# We check it
check_table('finalassignment.sqlite', 'top_tracks_data')
print(unique(artists_data$genre_category))
# We check it
check_table('finalassignment.sqlite', 'top_tracks_data')
print(unique(!is.na(artists_data$genre_category))
View(artists_data)
# We check it
check_table('finalassignment.sqlite', 'top_tracks_data')
print(unique(na.omit(artists_data$genre_category)))
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
# We will first load all the packages that we need for this assignment
# We call 'suppresWarnings()' to omit the warnings in the knitted document - in case we get some
suppressWarnings(library('DBI'))
suppressWarnings(library('RSQLite'))
library('rvest')
library('RSelenium')
library('httr')
library('dplyr')
library('ggplot2')
library('leaflet')
library('rnaturalearth')
library('stringr')
library('plotly')
library('shiny')
# We open the connection once again
connection <- dbConnect(RSQLite::SQLite(), mydatabase)
# Drop if exists
dbExecute(connection, "DROP TABLE IF EXISTS albums_final_data")
dbExecute(connection, "DROP TABLE IF EXISTS toptracks_final_data")
# Print the head(3) entries
print(str(albums_final_data)
str(albums_final_data)
str(albums_final_data)
# Print the head(3) entries
print(names(albums_final_data))
# Assuming your data frame is named cleaned_awards_data_wins
mean_popularity_per_wins <- cleaned_awards_data_wins %>%
group_by(wins) %>%
summarise(mean_popularity = mean(popularity, na.rm = TRUE))
# 6) Remove rows with NA values in 'wins', 'nominations', and 'popularity'
cleaned_awards_data_wins <- albums_final_data %>%
filter(!is.na(wins) & !is.na(popularity))
# Create an interactive scatter plot with Plotly for Wins
wins_plot <- plot_ly(
data = cleaned_awards_data_wins,
x = ~popularity,
y = ~wins,
text = ~artist,  # Display artist name on hover/click
color = ~wins,
type = "scatter",
mode = "markers"
) %>%
layout(
title = "Artist Popularity vs Wins",
xaxis = list(title = "Artist Popularity"),
yaxis = list(title = "Wins"),
coloraxis = list(colorscale = "Viridis")
)
# Print the Plotly object to the console
wins_plot
# 7) Remove rows with NA values in 'nominations', 'popularity'
cleaned_awards_data_nominations <- albums_final_data %>%
filter(!is.na(nominations) & !is.na(popularity))
# Create an interactive scatter plot with Plotly for Nominations
nominations_plot <- plot_ly(
data = cleaned_awards_data_nominations,
x = ~popularity,
y = ~nominations,
text = ~artist,  # Display artist name on hover/click
color = ~nominations,
type = "scatter",
mode = "markers"
) %>%
layout(
title = "Artist Popularity vs Nominations",
xaxis = list(title = "Artist Popularity"),
yaxis = list(title = "Nominations"),
coloraxis = list(colorscale = "Viridis")
)
# Print the Plotly object to the console
nominations_plot
# Assuming your data frame is named albums_final_data
correlation_matrix <- albums_final_data %>%
select(wins, nominations, followers_in_millions, popularity) %>%
na.omit() %>%
cor()
# Create an interactive heatmap for the correlation matrix
# Create an interactive heatmap for the correlation matrix with a reverse color scale
plot_ly(z = ~correlation_matrix, colorscale = "YlGnBu", reversescale = TRUE, type = "heatmap",
x = colnames(correlation_matrix), y = colnames(correlation_matrix),
text = ~paste("Correlation: ", round(correlation_matrix, 2))) %>%
layout(title = "Correlation Matrix: Wins, Nominations, Followers, Popularity",
xaxis = list(title = "Variables"),
yaxis = list(title = "Variables"))
# Assuming your data frame is named cleaned_awards_data_wins
mean_popularity_per_wins <- cleaned_awards_data_wins %>%
group_by(wins) %>%
summarise(mean_popularity = mean(popularity, na.rm = TRUE))
# Create an interactive scatter plot with Plotly (switch x and y)
scatter_plot_wins <- plot_ly(
data = mean_popularity_per_wins,
y = ~wins,  # Switched x and y here
x = ~mean_popularity,  # Switched x and y here
type = "scatter",
mode = "markers",
text = ~paste("Wins: ", wins, "<br>Mean Popularity: ", round(mean_popularity, 2))
) %>%
add_lines(
y = ~wins,  # Switched x and y here
x = ~fitted(lm(mean_popularity ~ wins, data = mean_popularity_per_wins)),  # Switched x and y here
type = "scatter",
mode = "lines",
line = list(color = "red"),
name = "Regression Line"
) %>%
layout(
title = "Mean Popularity Based on Wins with Regression Line",
xaxis = list(title = "Mean Popularity"),  # Switched x and y here
yaxis = list(title = "Number of Wins")  # Switched x and y here
)
# Print the Plotly object to the console
scatter_plot_wins
#_____________________________________________________
# Assuming your data frame is named cleaned_awards_data_nominations
mean_popularity_per_nominations <- cleaned_awards_data_nominations %>%
group_by(nominations) %>%
summarise(mean_popularity = mean(popularity, na.rm = TRUE))
# Create an interactive scatter plot with Plotly (switch x and y)
scatter_plot_nominations <- plot_ly(
data = mean_popularity_per_nominations,
y = ~nominations,  # Switched x and y here
x = ~mean_popularity,  # Switched x and y here
type = "scatter",
mode = "markers",
text = ~paste("Nominations: ", nominations, "<br>Mean Popularity: ", round(mean_popularity, 2))
) %>%
add_lines(
y = ~nominations,  # Switched x and y here
x = ~fitted(lm(mean_popularity ~ nominations, data = mean_popularity_per_nominations)),  # Switched x and y here
type = "scatter",
mode = "lines",
line = list(color = "red"),
name = "Regression Line"
) %>%
layout(
title = "Mean Popularity Based on Nominations with Regression Line",
xaxis = list(title = "Mean Popularity"),  # Switched x and y here
yaxis = list(title = "Number of Nominations")  # Switched x and y here
)
# Print the Plotly object to the console
scatter_plot_nominations
View(artists_data)
